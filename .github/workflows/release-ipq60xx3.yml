# 工作流名称：Release IPQ60XX
name: Release IPQ60XX3

# 触发条件：手动触发或定时触发（北京时间周五0点 = UTC时间周四16:00）
on:
  workflow_dispatch:
  schedule:
    - cron: '0 16 * * 4'

# 环境变量
env:
  GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
  # 定义芯片架构变量，仅用于区分缓存
  CHIP: ipq60xx

# 作业定义
jobs:
  # 构建作业
  build:
    # 策略：使用矩阵遍历所有设备模型
    strategy:
      matrix:
        model:
          - ipq60xx_immwrt_Pro
          - ipq60xx_immwrt_Max
          - ipq60xx_immwrt_Ultra
          - ipq60xx_libwrt_Pro
          - ipq60xx_libwrt_Max
          - ipq60xx_libwrt_Ultra
        os: [ubuntu-24.04] # 操作系统矩阵
      # 允许失败的任务继续执行
      fail-fast: false
      # 最大并行数，避免资源耗尽
      # max-parallel: 3

    # 运行环境
    runs-on: ${{ matrix.os }}
    
    # 步骤定义
    steps:
      # 步骤1：释放磁盘空间
      - name: Free disk space
        uses: sbwml/actions@free-disk
        
      # 步骤2：设置构建环境
      - name: Build System Setup
        run: |
          # 执行官方构建环境初始化脚本
          sudo bash -c 'bash <(curl -sL https://build-scripts.immortalwrt.org/init_build_environment.sh)'
          # 安装额外依赖包
          sudo -E apt -yqq install dos2unix
          sudo -E apt -yqq install libfuse-dev
          # 清理不需要的软件包
          sudo -E apt -yqq autoremove --purge
          sudo -E apt -yqq autoclean
          sudo -E apt -yqq clean
          sudo -E systemctl daemon-reload
          
      # 步骤3：检出代码
      - name: Checkout
        uses: actions/checkout@v4
        
      # 步骤4：设置脚本执行权限
      - name: Set Execute Permissions
        run: |
          echo "=== 设置执行权限 ==="
          # 为所有shell脚本添加执行权限
          find . -name "*.sh" -type f -exec sh -c 'head -n1 "$1" | grep -q "^#!/" && chmod +x "$1"' _ {} \;
          
      # 步骤5：设置构建日期和时区
      - name: Set Build Date and Timezone
        run: |
          # 设置时区为上海（北京时间）
          sudo -E timedatectl set-timezone "Asia/Shanghai"
          # 生成构建日期
          export BUILD_DATE=$(TZ=UTC-8 date +"%y.%m.%d_%H.%M.%S")
          echo "BUILD_DATE=$BUILD_DATE" >> $GITHUB_ENV
          echo "使用芯片架构: ${{ env.CHIP }}"
          
      # 步骤6：预克隆操作
      - name: Pre Clone
        run: ./scripts/pre_clone_action.sh ${{ matrix.model }}
        
      # 步骤7：缓存依赖项
      - name: Cache Dependencies
        uses: actions/cache@v4
        with:
          # 缓存路径
          path: |
            ./action_build/.ccache
            ./action_build/staging_dir
          # 优化缓存键：移除构建日期，提高缓存命中率
          key: ${{ matrix.os }}-${{ env.CHIP }}-${{ hashFiles('**/repo_flag') }}
          # 恢复键
          restore-keys: |
            ${{ matrix.os }}-${{ env.CHIP }}-${{ hashFiles('**/repo_flag') }}
            ${{ matrix.os }}-${{ env.CHIP }}-
            
      # 步骤8：刷新缓存
      - name: Refresh the cache
        run: |
          # 如果staging_dir存在，则刷新所有stamp文件的时间戳
          if [ -d "./action_build/staging_dir" ]; then
            find "./action_build/staging_dir" -type d -name "stamp" -not -path "*target*" | while read -r dir; do
                find "$dir" -type f -exec touch {} +
            done
          fi
          
      # 步骤9：构建固件并捕获日志
      - name: Build Firmware and Capture Logs
        id: build
        run: |
          # 设置日志文件路径 - 使用build.sh的临时目录结构
          FULL_LOG="./temp_firmware/${{ matrix.model }}/logs/build_full.log"
          ERROR_LOG="./temp_firmware/${{ matrix.model }}/logs/build_errors.log"
          WARNING_LOG="./temp_firmware/${{ matrix.model }}/logs/build_warnings.log"
          
          # 创建日志目录
          mkdir -p "$(dirname "$FULL_LOG")"
          
          # 创建空日志文件，确保文件存在
          touch "$FULL_LOG" "$ERROR_LOG" "$WARNING_LOG"
          
          # 执行构建脚本并捕获完整日志
          echo "开始构建 ${{ matrix.model }}..."
          ./scripts/build.sh ${{ matrix.model }} 2>&1 | tee "$FULL_LOG"
          BUILD_EXIT_CODE=${PIPESTATUS[0]}
          
          # 检查日志文件是否存在
          if [ ! -f "$FULL_LOG" ]; then
            echo "错误: 完整日志文件不存在: $FULL_LOG"
            echo "build_status=failed" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          # 确保错误和警告日志文件存在
          touch "$ERROR_LOG" "$WARNING_LOG"
          
          # 从完整日志中提取错误信息
          echo "=== 错误日志 ===" > "$ERROR_LOG"
          grep -i "error\|failed\|failure" "$FULL_LOG" | grep -v "make.*error.*required" >> "$ERROR_LOG" || echo "未发现错误信息" >> "$ERROR_LOG"
          
          # 从完整日志中提取警告信息
          echo "=== 警告日志 ===" > "$WARNING_LOG"
          grep -i "warning\|warn" "$FULL_LOG" >> "$WARNING_LOG" || echo "未发现警告信息" >> "$WARNING_LOG"
          
          # 如果日志文件过大，进行压缩
          if [ -f "$FULL_LOG" ] && [ $(stat -c%s "$FULL_LOG" 2>/dev/null || echo 0) -gt 10485760 ]; then
            echo "压缩大日志文件..."
            gzip "$FULL_LOG"
            FULL_LOG="${FULL_LOG}.gz"
          fi
          
          # 输出构建状态
          if [ $BUILD_EXIT_CODE -ne 0 ]; then
            echo "::error::构建失败，退出码: $BUILD_EXIT_CODE"
            echo "build_status=failed" >> $GITHUB_OUTPUT
          else
            echo "构建成功"
            echo "build_status=success" >> $GITHUB_OUTPUT
          fi
          
          echo "构建日志已保存到:"
          echo "- 完整日志: $FULL_LOG"
          echo "- 错误日志: $ERROR_LOG"
          echo "- 警告日志: $WARNING_LOG"
          
          # 列出日志目录内容，用于调试
          echo "日志目录内容:"
          ls -la "$(dirname "$FULL_LOG")"
          
          # 检查temp_firmware目录是否存在
          if [ -d "./temp_firmware/${{ matrix.model }}" ]; then
            echo "temp_firmware目录内容:"
            ls -la ./temp_firmware/${{ matrix.model }}/
          else
            echo "警告: temp_firmware/${{ matrix.model }} 目录不存在"
          fi
          
      # 步骤10：删除旧缓存
      - name: Delete Old Cache
        if: always()
        run: |
          # 获取缓存列表并删除旧缓存
          gh cache list --key ${{ matrix.os }}-${{ env.CHIP }}-${{ hashFiles('**/repo_flag') }}- --json key --jq '.[] | .key' | while read -r key; do
            gh cache delete "$key"
          done
          # 输出缓存状态
          echo "========cache status========"
          echo "ccache: $(du -sh ./action_build/.ccache | cut -f 1)"
          echo "staging: $(du -sh ./action_build/staging_dir | cut -f 1)"
          
      # 步骤11：显示机器信息
      - name: Machine Information
        run: |
          echo "=============================================="
          lscpu | grep -E "name|Core|Thread"
          echo "=============================================="
          df -h
          echo "=============================================="
          
      # 步骤12：上传构建产物
      - name: Upload Firmware Artifacts
        uses: actions/upload-artifact@v4
        with:
          # 产物名称
          name: firmware-${{ matrix.model }}
          # 产物路径
          path: ./temp_firmware/${{ matrix.model }}/
          # 保留天数
          retention-days: 3
          
      # 步骤13：检查构建状态
      - name: Check Build Status
        if: steps.build.outputs.build_status == 'failed'
        run: |
          echo "::error::构建失败，请检查日志"
          exit 1

  # 发布作业
  release:
    # 依赖构建作业，即使部分构建失败也继续执行
    needs: build
    # 运行环境
    runs-on: ubuntu-24.04
    # 步骤定义
    steps:
      # 步骤1：检出代码
      - name: Checkout
        uses: actions/checkout@v4
        
      # 步骤2：设置构建日期
      - name: Set Build Date
        run: |
          # 设置时区并生成构建日期
          sudo -E timedatectl set-timezone "Asia/Shanghai"
          export BUILD_DATE=$(TZ=UTC-8 date +"%y.%m.%d_%H.%M.%S")
          echo "BUILD_DATE=$BUILD_DATE" >> $GITHUB_ENV
          
      # 步骤3：下载所有构建产物
      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          # 下载路径
          path: all-firmware
          
      # 步骤4：准备固件目录和发布说明
      - name: Prepare firmware directory and release notes
        run: |
          # 创建固件目录
          mkdir -p firmware
          
          # 高效复制所有固件文件（排除ipk、apk和logs目录）
          # 使用rsync替代find+cp，更高效
          rsync -av --prune-empty-dirs --include="*/" --include="*.*" --exclude="ipk/" --exclude="apk/" --exclude="logs/" all-firmware/ firmware/
          
          # 并行处理IPK、APK和日志目录
          # 创建临时目录用于并行处理
          mkdir -p temp/ipk temp/apk temp/logs
          
          # 使用xargs并行复制IPK目录
          find all-firmware -name "ipk" -type d | xargs -I {} -P $(nproc) bash -c '
            model_dir=$(dirname "{}")
            model_name=$(basename "$model_dir")
            mkdir -p "temp/ipk/$model_name"
            cp -r "{}"/* "temp/ipk/$model_name/" 2>/dev/null || true
          '
          
          # 使用xargs并行复制APK目录
          find all-firmware -name "apk" -type d | xargs -I {} -P $(nproc) bash -c '
            model_dir=$(dirname "{}")
            model_name=$(basename "$model_dir")
            mkdir -p "temp/apk/$model_name"
            cp -r "{}"/* "temp/apk/$model_name/" 2>/dev/null || true
          '
          
          # 使用xargs并行复制日志目录
          find all-firmware -name "logs" -type d | xargs -I {} -P $(nproc) bash -c '
            model_dir=$(dirname "{}")
            model_name=$(basename "$model_dir")
            mkdir -p "temp/logs/$model_name"
            cp -r "{}"/* "temp/logs/$model_name/" 2>/dev/null || true
          '
          
          # 合并IPK目录
          if [ -d "temp/ipk" ] && [ "$(ls -A temp/ipk 2>/dev/null)" ]; then
            mkdir -p firmware/ipk
            find temp/ipk -name "*.ipk" -type f -exec cp -t firmware/ipk/ {} +
          fi
          
          # 合并APK目录
          if [ -d "temp/apk" ] && [ "$(ls -A temp/apk 2>/dev/null)" ]; then
            mkdir -p firmware/apk
            find temp/apk -name "*.apk" -type f -exec cp -t firmware/apk/ {} +
          fi
          
          # 移动日志目录
          if [ -d "temp/logs" ] && [ "$(ls -A temp/logs 2>/dev/null)" ]; then
            mv temp/logs firmware/
          fi
          
          # 清理临时目录
          rm -rf temp
          
          # 进入固件目录
          cd firmware
          
          # 并行创建压缩包
          # 创建IPK压缩包
          if [ -d "ipk" ] && [ "$(ls -A ipk 2>/dev/null)" ]; then
              echo "Creating ipk_packages.tar.gz..."
              tar -czf ipk_packages.tar.gz ipk/ && rm -rf ipk || echo "错误: ipk_packages.tar.gz 创建失败"
          fi
          
          # 创建APK压缩包
          if [ -d "apk" ] && [ "$(ls -A apk 2>/dev/null)" ]; then
              echo "Creating apk_packages.tar.gz..."
              tar -czf apk_packages.tar.gz apk/ && rm -rf apk || echo "错误: apk_packages.tar.gz 创建失败"
          fi
          
          # 创建日志压缩包
          if [ -d "logs" ] && [ "$(ls -A logs 2>/dev/null)" ]; then
              echo "Creating build_logs.tar.gz..."
              # 使用pigz替代gzip，利用多核压缩
              if command -v pigz >/dev/null 2>&1; then
                tar -cf - logs/ | pigz -9 > build_logs.tar.gz && rm -rf logs || echo "错误: build_logs.tar.gz 创建失败"
              else
                tar -czf build_logs.tar.gz logs/ && rm -rf logs || echo "错误: build_logs.tar.gz 创建失败"
              fi
          fi
          
          # 返回上级目录
          cd ..
          
          # 创建发布说明
          echo "IPQ60xx 固件批量发布" > release_body.txt
          echo "构建时间: $BUILD_DATE" >> release_body.txt
          echo "包含以下型号:" >> release_body.txt
          echo "- ipq60xx_immwrt_Pro" >> release_body.txt
          echo "- ipq60xx_immwrt_Max" >> release_body.txt
          echo "- ipq60xx_immwrt_Ultra" >> release_body.txt
          echo "- ipq60xx_libwrt_Pro" >> release_body.txt
          echo "- ipq60xx_libwrt_Max" >> release_body.txt
          echo "- ipq60xx_libwrt_Ultra" >> release_body.txt
          echo "" >> release_body.txt
          echo "WIFI密码: 12345678" >> release_body.txt
          echo "LAN地址: 192.168.111.1" >> release_body.txt
          echo "" >> release_body.txt
          echo "本发布包含以下文件:" >> release_body.txt
          echo "- 京东云亚瑟、雅典娜的Pro/Max/Ultra配置固件及配置文件 (.bin, .manifest, .config，.config.buildinfo等)" >> release_body.txt
          
          # 根据实际情况添加ipk和apk包的信息
          if [ -f "firmware/ipk_packages.tar.gz" ]; then
              echo "- 合并后的ipk包 (ipk_packages.tar.gz)" >> release_body.txt
              echo "" >> release_body.txt
              
              # 从压缩包中提取IPK包数量
              IPK_COUNT=$(tar -tzf firmware/ipk_packages.tar.gz | grep '\.ipk$' | wc -l)
              echo "IPK包数量: $IPK_COUNT" >> release_body.txt
              
              # 提取并显示所有luci-app包名（去重）
              echo "" >> release_body.txt
              echo "包含的luci-app包:" >> release_body.txt
              tar -tzf firmware/ipk_packages.tar.gz | grep 'luci-app-.*\.ipk$' | sed -E 's/.*\///; s/\.ipk$//' | sort | uniq >> release_body.txt
          fi
          
          if [ -f "firmware/apk_packages.tar.gz" ]; then
              echo "- 合并后的apk包 (apk_packages.tar.gz)" >> release_body.txt
              echo "" >> release_body.txt
              
              # 从压缩包中提取APK包数量
              APK_COUNT=$(tar -tzf firmware/apk_packages.tar.gz | grep '\.apk$' | wc -l)
              echo "APK包数量: $APK_COUNT" >> release_body.txt
          fi
          
          # 添加构建日志信息
          if [ -f "firmware/build_logs.tar.gz" ]; then
              echo "- 构建日志 (build_logs.tar.gz)" >> release_body.txt
              echo "" >> release_body.txt
              
              # 分析日志摘要
              echo "构建状态摘要:" >> release_body.txt
              
              # 检查是否有错误日志
              ERROR_MODELS=$(tar -tzf firmware/build_logs.tar.gz | grep -c "build_errors.log" || echo 0)
              if [ "$ERROR_MODELS" -gt 0 ]; then
                  ERROR_COUNT=0
                  for model in $(tar -tzf firmware/build_logs.tar.gz | grep "build_errors.log" | xargs dirname | sort | uniq); do
                    # 检查每个模型的错误日志
                    if tar -xf firmware/build_logs.tar.gz "$model/build_errors.log" -O | grep -q "未发现错误信息"; then
                      continue
                    else
                      ERROR_COUNT=$((ERROR_COUNT + 1))
                    fi
                  done
                  
                  if [ "$ERROR_COUNT" -gt 0 ]; then
                    echo "- 发现 $ERROR_COUNT 个模型存在构建错误" >> release_body.txt
                  else
                    echo "- 未发现构建错误" >> release_body.txt
                  fi
              else
                  echo "- 错误日志文件不存在" >> release_body.txt
              fi
              
              # 检查是否有警告日志
              WARNING_MODELS=$(tar -tzf firmware/build_logs.tar.gz | grep -c "build_warnings.log" || echo 0)
              if [ "$WARNING_MODELS" -gt 0 ]; then
                  WARNING_COUNT=0
                  for model in $(tar -tzf firmware/build_logs.tar.gz | grep "build_warnings.log" | xargs dirname | sort | uniq); do
                    # 检查每个模型的警告日志
                    if tar -xf firmware/build_logs.tar.gz "$model/build_warnings.log" -O | grep -q "未发现警告信息"; then
                      continue
                    else
                      WARNING_COUNT=$((WARNING_COUNT + 1))
                    fi
                  done
                  
                  if [ "$WARNING_COUNT" -gt 0 ]; then
                    echo "- 发现 $WARNING_COUNT 个模型存在构建警告" >> release_body.txt
                  else
                    echo "- 未发现构建警告" >> release_body.txt
                  fi
              else
                  echo "- 警告日志文件不存在" >> release_body.txt
              fi
              
              echo "" >> release_body.txt
              echo "日志文件说明:" >> release_body.txt
              echo "- build_full.log(.gz): 完整构建日志" >> release_body.txt
              echo "- build_errors.log: 提取的错误信息" >> release_body.txt
              echo "- build_warnings.log: 提取的警告信息" >> release_body.txt
              echo "- 日志按模型分类存放，请查看对应目录" >> release_body.txt
          fi
          
      # 步骤5：发布固件
      - name: Release Firmware
        uses: softprops/action-gh-release@v2
        with:
          # 标签名称
          tag_name: ${{ env.BUILD_DATE }}-${{ env.CHIP }}
          # 发布文件（包含所有文件，包括打包后的tar.gz）
          files: ./firmware/*
          # 发布说明文件路径
          body_path: ./release_body.txt
