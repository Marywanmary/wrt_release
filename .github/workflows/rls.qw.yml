name: Release IPQ QWB
on:
  workflow_dispatch:
  schedule:
    # 北京时间周五0点 = UTC时间周四16:00
    - cron: '0 16 * * 4'
env:
  GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
  # 定义芯片架构变量，仅用于区分缓存，缓存键(key)是区分不同缓存的唯一方式
  CHIP: ipq60xx
jobs:
  build:
    strategy:
      matrix:
        model:
          - ipq60xx_immwrt_Pro
          - ipq60xx_immwrt_Max
          - ipq60xx_immwrt_Ultra
          - ipq60xx_libwrt_Pro
          - ipq60xx_libwrt_Max
          - ipq60xx_libwrt_Ultra
        os: [ubuntu-24.04] # 矩阵用于遍历所有设备模型，实现批量编译，每个模型需要独立的构建环境和输出，保留矩阵可以方便未来扩展。
      # max-parallel: 3
    runs-on: ${{ matrix.os }}
    steps:
      - name: Free disk space
        uses: sbwml/actions@free-disk
      - name: Build System Setup
        run: |
          sudo bash -c 'bash <(curl -sL https://build-scripts.immortalwrt.org/init_build_environment.sh)'
          sudo -E apt -yqq install dos2unix
          sudo -E apt -yqq install libfuse-dev
          sudo -E apt -yqq autoremove --purge
          sudo -E apt -yqq autoclean
          sudo -E apt -yqq clean
          sudo -E systemctl daemon-reload
      - name: Checkout
        uses: actions/checkout@v4
      - name: Set Execute Permissions
        run: |
          echo "=== 设置执行权限 ==="
          find . -name "*.sh" -type f -exec sh -c 'head -n1 "$1" | grep -q "^#!/" && chmod +x "$1"' _ {} \;
      - name: Set Build Date and Timezone
        run: |
          sudo -E timedatectl set-timezone "Asia/Shanghai"
          export BUILD_DATE=$(TZ=UTC-8 date +"%y.%m.%d_%H.%M.%S")
          echo "BUILD_DATE=$BUILD_DATE" >> $GITHUB_ENV
          export BUILD_SRC=$(awk -F"=" '/REPO_URL/ {print $NF}' "./compilecfg/${{ matrix.model }}.ini")
          echo "BUILD_SRC=$BUILD_SRC" >> $GITHUB_ENV
          echo "使用芯片架构: ${{ env.CHIP }}"
      - name: Pre Clone
        run: ./pre_clone_action.sh ${{ matrix.model }}
      - name: Cache Dependencies
        uses: actions/cache@v4
        with:
          path: |
            ./action_build/.ccache
            ./action_build/staging_dir
          # 使用预定义的CHIP变量
          key: ${{ matrix.os }}-${{ env.CHIP }}-${{ hashFiles('**/repo_flag') }}-${{ env.BUILD_DATE }}
          restore-keys: |
            ${{ matrix.os }}-${{ env.CHIP }}-${{ hashFiles('**/repo_flag') }}-
            ${{ matrix.os }}-${{ env.CHIP }}-
      - name: Refresh the cache
        run: |
          if [ -d "./action_build/staging_dir" ]; then
            find "./action_build/staging_dir" -type d -name "stamp" -not -path "*target*" | while read -r dir; do
                find "$dir" -type f -exec touch {} +
            done
          fi
      - name: Build Firmware
        run: ./build.cz.sh ${{ matrix.model }}
      - name: Get Kernel Version
        run: |
          # 获取内核版本
          echo "KVER=$(find ./action_build/dl -maxdepth 1 -name "linux-[4-6]\.*" | sort -r | head -n 1 | grep -oE "[4-6]\.[0-9]{1,3}\.[0-9]{1,3}")" >> $GITHUB_ENV
      - name: Delete Old Cache
        run: |
          # 获取缓存列表并删除
          gh cache list --key ${{ matrix.os }}-${{ env.CHIP }}-${{ hashFiles('**/repo_flag') }}- --json key --jq '.[] | .key' | while read -r key; do
            gh cache delete "$key"
          done
          # 输出缓存状态
          echo "========cache status========"
          echo "ccache: $(du -sh ./action_build/.ccache | cut -f 1)"
          echo "staging: $(du -sh ./action_build/staging_dir | cut -f 1)"
      - name: Machine Information
        run: |
          echo "=============================================="
          lscpu | grep -E "name|Core|Thread"
          echo "=============================================="
          df -h
          echo "=============================================="
      - name: Prepare Release Body
        run: |
          echo "云编译发布" > release_body.txt
          echo "源码：${{ env.BUILD_SRC }}" >> release_body.txt
          echo "Kernel: ${{ env.KVER }}" >> release_body.txt
          echo "WIFI密码: 12345678" >> release_body.txt
          echo "LAN地址: 192.168.111.1" >> release_body.txt
          echo "插件：" >> release_body.txt
          # 注意：这里假设每个 firmware 包含一个 manifest 文件，或者你有其他方式获取插件列表
          # 如果没有 manifest，可以考虑使用通配符获取所有 manifest 文件内容
          # 以下命令尝试从所有 manifest 文件中提取 luci-app 插件名称
          # 如果 ./firmware/*.manifest 不存在，则此行会报错，但不会中断整个流程
          # 你可以根据实际情况调整
          echo "正在扫描插件..."
          if [ -f ./firmware/*.manifest ]; then
             echo "$(grep -oP "luci-app(-[a-zA-Z0-9]{1,}){1,}" ./firmware/*.manifest | awk -F":" '{print $NF}' | sort -u)" >> release_body.txt
          else
             echo "未找到 manifest 文件" >> release_body.txt
          fi

      # 新增步骤：收集并合并所有 .ipk 和 .apk 文件
      - name: Collect and Merge Packages
        id: collect_packages
        run: |
          echo "=== 收集并合并所有 .ipk 和 .apk 文件 ==="
          mkdir -p ./release_packages

          # 1. 查找所有可能的 .ipk 和 .apk 文件路径
          # 假设 .ipk 文件在 action_build/packages/ 目录下
          # 假设 .apk 文件在 action_build/packages/ 目录下
          # 请注意：实际路径可能需要根据 build.cz.sh 的行为进行调整
          # 以下是一个通用方法，查找所有 .ipk 和 .apk 文件
          echo "搜索 .ipk 文件..."
          find ./action_build -type f -name "*.ipk" -o -name "*.apk" 2>/dev/null | while read -r pkg_file; do
            echo "找到包: $pkg_file"
            # 获取文件名
            basename_pkg=$(basename "$pkg_file")
            echo "文件名: $basename_pkg"
            # 检查是否已存在同名文件 (简单检查)
            if [ ! -f "./release_packages/$basename_pkg" ]; then
              echo "复制 $basename_pkg 到 release_packages 目录"
              cp "$pkg_file" "./release_packages/"
            else
              echo "警告: 文件 $basename_pkg 已存在于 release_packages 目录，跳过。"
            fi
          done

          # 2. 打印收集到的文件列表
          echo "=== 发布包列表 ==="
          ls -la ./release_packages/

          # 3. 记录收集到的文件数量 (可选，用于调试)
          count=$(ls -1 ./release_packages/*.ipk ./release_packages/*.apk 2>/dev/null | wc -l)
          echo "共收集到 $count 个软件包。"
          echo "PACKAGES_COUNT=$count" >> $GITHUB_ENV

      - name: Release Firmware and Packages
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ env.BUILD_DATE }}
          files: |
            ./firmware/*.*
            ./release_packages/*.ipk
            ./release_packages/*.apk
          body_path: ./release_body.txt
